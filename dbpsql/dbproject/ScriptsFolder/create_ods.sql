CREATE SCHEMA IF NOT EXISTS odins;
CREATE SCHEMA IF NOT EXISTS staging;

CREATE TABLE IF NOT EXISTS public.codegen_dwh_column
(
    codegen_dwh_column_id integer           NOT NULL,
    codegen_dwh_table_id  integer           NOT NULL,
    column_name           character varying(128) COLLATE pg_catalog."default" NOT NULL,
    data_type             character varying(128) COLLATE pg_catalog."default" NOT NULL,
    text_length           integer           NULL,
    precision             integer           NULL,
    scale                 integer           NULL,
    is_enable             boolean           CONSTRAINT DF_codegen_dwh_column_is_enable_DEFAULT DEFAULT ((true)) NOT NULL,
    is_versionkey         boolean           CONSTRAINT DF_codegen_dwh_column_is_versionkey_DEFAULT DEFAULT ((false)) NOT NULL,
    is_nulable            boolean           CONSTRAINT DF_codegen_dwh_column_is_nulable_DEFAULT DEFAULT ((true)) NOT NULL,
    null_value            character varying(128),
    CONSTRAINT "PK_codegen_dwh_column" PRIMARY KEY (codegen_dwh_column_id)

)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.codegen_dwh_column
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.codegen_dwh_table
(

    codegen_dwh_table_id  integer           NOT NULL,
    codegen_id            integer           NOT NULL,
    table_name            character varying(128) COLLATE pg_catalog."default" NOT NULL,
    is_root               boolean           NOT NULL,
    is_enable             boolean           NOT NULL,
    dwh_table_name        character varying(128) COLLATE pg_catalog."default" NOT NULL,
    is_vkey_session       boolean           CONSTRAINT DF_codegen_dwh_table_is_vkey_session_DEFAULT DEFAULT ((true)) NOT NULL,
    is_vkey_sourcename    boolean           CONSTRAINT DF_codegen_dwh_table_is_vkey_sourcename_DEFAULT DEFAULT ((true)) NOT NULL,
    is_historical         boolean           CONSTRAINT DF_codegen_dwh_table_is_historical_DEFAULT DEFAULT ((true)) NOT NULL,
    CONSTRAINT "PK_codegen_dwh_table" PRIMARY KEY (codegen_dwh_table_id)

)
TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.codegen_dwh_table
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.codegen_enable_type
(
    codegen_enable_type_id  smallint NOT NULL,
    description   character varying(256) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "PK_codegen_enable_type" PRIMARY KEY (codegen_enable_type_id)
)


TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.codegen_enable_type
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.codegen
(
    codegen_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    namespace character varying(256) COLLATE pg_catalog."default" NOT NULL,
    schema character varying(128) COLLATE pg_catalog."default" NOT NULL,
    table_name character varying(128) COLLATE pg_catalog."default" NOT NULL,
    ods_enable_type smallint NULL,
    dwh_enable_type smallint NULL,
    landing_enable_type smallint NULL,
    CONSTRAINT "PK_codegen" PRIMARY KEY (codegen_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.codegen
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.data_source(
    data_source_id smallint NOT NULL,
    name           character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "PK_data_source" PRIMARY KEY (data_source_id)
);
CREATE TABLE IF NOT EXISTS dwh_processing_details (
    processing_id  bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) PRIMARY KEY,
    dwh_session_id bigint        NULL,
    schema_name    varchar (128) NULL,
    table_name     varchar (128) NULL,
    row_count      bigint        NULL
);

CREATE TABLE IF NOT EXISTS dwh_session_log (
    dwh_session_log_id   bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) PRIMARY KEY,
    dwh_session_id       bigint         NOT NULL,
    dwh_session_state_id smallint        NOT NULL,
    error_message        varchar(4000) NULL,
    dt_create            timestamp with time zone NOT NULL 
);

CREATE TABLE IF NOT EXISTS dwh_session_state (
    dwh_session_state_id smallint     NOT NULL,
    name                 varchar(100) NULL
);
CREATE TABLE IF NOT EXISTS dwh_session (
    dwh_session_id       bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) PRIMARY KEY,
    data_source_id       smallint         NOT NULL,
    dwh_session_state_id smallint         NOT NULL,
    create_session       timestamp with time zone,
    error_message        varchar(4000) NULL,
    dt_update            timestamp with time zone NOT NULL default now(),
    dt_create            timestamp with time zone NOT NULL default now()
    
);


CREATE TABLE IF NOT EXISTS public.filequeue (
    filequeue_id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) ,
    session_id   bigint  NOT NULL,
    msg_key      character varying(256) COLLATE pg_catalog."default" NOT NULL,
    msg_id       uuid NULL,
    start_date   timestamp with time zone NULL,
    finish_date  timestamp with time zone NULL,
    filename     character varying(4000) COLLATE pg_catalog."default" NULL,
    filefolder   character varying(4000) COLLATE pg_catalog."default" NULL,
    filetype     character varying(4) COLLATE pg_catalog."default" NULL,
    error_msg    character varying(4000) COLLATE pg_catalog."default" NULL,
    state_id     smallint NOT NULL,
    dt_create    timestamp with time zone  CONSTRAINT DF_filequeue_create_date_DEFAULT DEFAULT (now()) NOT NULL,
    dt_update    timestamp with time zone  CONSTRAINT DF_filequeue_update_date_DEFAULT DEFAULT (now()) NOT NULL,
    CONSTRAINT PK_filequeue PRIMARY KEY (filequeue_id)
);



CREATE TABLE IF NOT EXISTS public.metaadapter 
(
    metaadapter_id smallint NOT NULL,
    name           character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "PK_metaadapter" PRIMARY KEY (metaadapter_id)
);

CREATE TABLE IF NOT EXISTS public.metadata_buffer
(
    buffer_id   bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    session_id  bigint           NOT NULL,
    msg_id      character varying(36) COLLATE pg_catalog."default",
    msg         text COLLATE pg_catalog."default",
    is_error    boolean       CONSTRAINT DF_metadata_buffer_is_error_DEFAULT DEFAULT ((false)) NOT NULL,
    dt_create   timestamp with time zone NOT NULL default now(),
    dt_update   timestamp without time zone NOT NULL DEFAULT to_date('19000101', 'YYYYMMDD')
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.metadata_buffer
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.metadata
(
    nkey           uuid NOT NULL,
    namespace      character varying(256) COLLATE pg_catalog."default",
    namespace_ver  character varying(256) COLLATE pg_catalog."default",
    msg            text COLLATE pg_catalog."default",
    metaadapter_id smallint NOT NULL,
    dt_create      timestamp with time zone NOT NULL,
    CONSTRAINT "PK_metadata" PRIMARY KEY (nkey)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.metadata
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.metamap
(
    metamap_id     smallint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 32767 CACHE 1 ),
    msg_key        character varying(128) COLLATE pg_catalog."default" NOT NULL,
    table_name     character varying(128) COLLATE pg_catalog."default" NOT NULL,
    metaadapter_id smallint NOT NULL,
    namespace      character varying(256) COLLATE pg_catalog."default",
    namespace_ver  character varying(256) COLLATE pg_catalog."default",
    etl_query      character varying(256) COLLATE pg_catalog."default",
    import_query   character varying(256) COLLATE pg_catalog."default",
    is_enable      boolean NOT NULL,
    CONSTRAINT "PK_metamap" PRIMARY KEY (metamap_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.metamap
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.msgqueue
(
    buffer_id  bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    session_id integer NOT NULL,
    msg_id     uuid NOT NULL,
    msg        text COLLATE pg_catalog."default",
    msg_key    character varying(128) COLLATE pg_catalog."default",
    dt_create  timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT "PK_msgqueue" PRIMARY KEY (buffer_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.msgqueue
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.session_log 
(

    session_log_id   bigint    NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    session_id       bigint   NOT NULL,
    session_state_id smallint  NOT NULL,
    error_message    character varying(4000) COLLATE pg_catalog."default",
    dt_create        timestamp with time zone  CONSTRAINT DF_session_log_date_DEFAULT DEFAULT (now()) NOT NULL,
    CONSTRAINT "PK_session_log" PRIMARY KEY (session_log_id)
);

CREATE TABLE IF NOT EXISTS public.session_state 
(
    session_state_id smallint       NOT NULL,
    name             character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "PK_session_state" PRIMARY KEY (session_state_id )
);


CREATE TABLE IF NOT EXISTS public.session (
    session_id       bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) ,
    data_source_id   smallint        NOT NULL,
    session_state_id smallint    NOT NULL,
    error_message    character varying(4000) COLLATE pg_catalog."default" NULL,
    dt_update        timestamp with time zone  CONSTRAINT DF_session_update_date_DEFAULT DEFAULT (now()) NOT NULL,
    dt_create        timestamp with time zone  CONSTRAINT DF_session_create_date_DEFAULT DEFAULT (now()) NOT NULL,
    CONSTRAINT PK_session PRIMARY KEY (session_id)
);



do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE "dwh_ArchiveTables"';
END;
$$;

CREATE OR REPLACE PROCEDURE "dwh_ArchiveTables" (
    par_dwh_session_id inout bigint DEFAULT NULL
)
AS $BODY$
DECLARE
    var_RowCount int;
    var_LocalRowCount  int;
BEGIN

    DELETE FROM odins.DIM_Валюты WHERE dwh_session_id = pat_dwh_session_id;

    DELETE FROM odins.DIM_Валюты_Представления WHERE dwh_session_id = par_dwh_session_id;

    DELETE FROM odins.DIM_Клиенты WHERE dwh_session_id = pat_dwh_session_id;

    DELETE FROM odins.DIM_Товары WHERE dwh_session_id = pat_dwh_session_id;

    DELETE FROM odins.FACT_Продажи WHERE dwh_session_id = pat_dwh_session_id;

    DELETE FROM odins.FACT_Продажи_Товары WHERE dwh_session_id = par_dwh_session_id;


    UPDATE dwh_session SET dwh_session_state_id = 6
    WHERE dwh_session_id = par_dwh_session_id;

END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE "dwh_AssignSessionID"';
END;
$$;

-- SELECT * FROM dwh_processing_details
-- call public."dwh_AssignSessionID" (null, null)
CREATE OR REPLACE PROCEDURE "dwh_AssignSessionID" (
    INOUT par_dwh_session_id bigint DEFAULT NULL::bigint,
    INOUT par_rowcount bigint DEFAULT NULL::bigint,
    INOUT par_create_session timestamp DEFAULT NULL::timestamp
)
AS $BODY$
DECLARE
    var_RowCount INTEGER;
    var_LocalRowCount INTEGER;
BEGIN

    par_rowcount:= 0;
    IF NOT par_dwh_session_id IS NULL AND par_dwh_session_id != -1 THEN

        SELECT INTO par_dwh_session_id, par_rowcount, par_create_session
        FROM (
            SELECT s.dwh_session_id, sum(row_count) as row_count, MAX(s.create_session) AS create_session
            FROM dwh_session s
                INNER JOIN dwh_processing_details p ON p.dwh_session_id = s.dwh_session_id
            WHERE dwh_session_state_id = 2 AND s.dwh_session_id = par_dwh_session_id
            GROUP BY s.dwh_session_id
        ) s;
        RETURN ;
    END IF;

    IF par_dwh_session_id IS NULL OR par_dwh_session_id = -1 THEN
        SELECT  min(dwh_session_id) into par_dwh_session_id FROM dwh_session WHERE (par_dwh_session_id IS NULL OR par_dwh_session_id != -1) AND dwh_session_state_id = 2;

        RAISE NOTICE 'N1 par_dwh_session_id  %', par_dwh_session_id;

        IF NOT par_dwh_session_id IS NULL THEN
            SELECT COALESCE(create_session,now()) INTO par_create_session FROM dwh_session WHERE dwh_session_id = par_dwh_session_id; 
            SELECT COALESCE(SUM(row_count),0) INTO par_rowcount
            FROM dwh_processing_details WHERE dwh_session_id = par_dwh_session_id
            GROUP BY dwh_session_id;
            RAISE NOTICE 'N2 par_dwh_session_id  %', par_dwh_session_id;
            RETURN;
        END IF;

        call public."dwh_SaveSessionState" ( par_dwh_session_id::bigint , 1::smallint, 1::smallint, null::varchar(4000) );
    END IF;
    
    IF var_RowCount > 0 THEN
        call dwh_SaveSessionState (par_dwh_session_id, 2, null,null);
    END IF;
--DIM_Валюты
    LOCK TABLE odins."DIM_Валюты" IN ROW EXCLUSIVE MODE;
    DROP TABLE IF EXISTS "tmp_DIM_Валюты";
    CREATE TEMPORARY TABLE "tmp_DIM_Валюты"(
        ods_id bigint Primary Key,
        "RefID" uuid
    );
    INSERT INTO "tmp_DIM_Валюты" (
        ods_id, "RefID"
    )
    SELECT ods_id, "RefID" FROM odins."DIM_Валюты" FOR UPDATE;

    GET DIAGNOSTICS var_rowcount = ROW_COUNT;
    par_rowcount := par_rowcount + var_rowcount;

    IF var_rowcount > 0 THEN
        INSERT INTO dwh_processing_details( dwh_session_id, schema_name, table_name, row_count)
        SELECT par_dwh_session_id, 'odins', 'DIM_Валюты',var_rowcount;
    END IF;

    DELETE FROM odins."DIM_Валюты_history" WHERE dwh_session_id = par_dwh_session_id;

    INSERT INTO odins."DIM_Валюты_history"(
        nkey,
        dwh_session_id,
        "RefID",
        "DeletionMark",
        "Code",
        "Description",
        "ЗагружаетсяИзИнтернета",
        "НаименованиеПолное",
        "Наценка",
        "ОсновнаяВалюта",
        "ПараметрыПрописи",
        "ФормулаРасчетаКурса",
        "СпособУстановкиКурса",
        dt_create
    )
    SELECT
        b.nkey,
        par_dwh_session_id AS dwh_session_id,
        b."RefID",
        b."DeletionMark",
        b."Code",
        b."Description",
        b."ЗагружаетсяИзИнтернета",
        b."НаименованиеПолное",
        b."Наценка",
        b."ОсновнаяВалюта",
        b."ПараметрыПрописи",
        b."ФормулаРасчетаКурса",
        b."СпособУстановкиКурса",
        now() AS dt_create
    FROM odins."DIM_Валюты" b
        INNER JOIN "tmp_DIM_Валюты" ll ON b.ods_id = ll.ods_id;


    DELETE FROM odins."DIM_Валюты_Представления_history" WHERE dwh_session_id = par_dwh_session_id;

    INSERT INTO odins."DIM_Валюты_Представления_history"(
        nkey,
        dwh_session_id,
        "DIM_ВалютыRefID",
        "КодЯзыка",
        "ПараметрыПрописи",
        dt_create
    )
    SELECT
        b.nkey,
        par_dwh_session_id AS dwh_session_id,
        b."DIM_ВалютыRefID",
        b."КодЯзыка",
        b."ПараметрыПрописи",
        now() AS dt_create
    FROM odins."DIM_Валюты_Представления" b
        INNER JOIN "tmp_DIM_Валюты" ll ON b."DIM_ВалютыRefID" = ll."RefID";


    GET DIAGNOSTICS var_rowcount = ROW_COUNT;
    par_rowcount := par_rowcount + var_rowcount;

    IF var_rowcount > 0 THEN
        INSERT INTO dwh_processing_details( dwh_session_id, schema_name, table_name, row_count)
        SELECT par_dwh_session_id, 'odins', 'DIM_Валюты_Представления',var_rowcount;
    END IF;

    COMMIT;
--DIM_Клиенты
    LOCK TABLE odins."DIM_Клиенты" IN ROW EXCLUSIVE MODE;
    DROP TABLE IF EXISTS "tmp_DIM_Клиенты";
    CREATE TEMPORARY TABLE "tmp_DIM_Клиенты"(
        ods_id bigint Primary Key,
        "RefID" uuid
    );
    INSERT INTO "tmp_DIM_Клиенты" (
        ods_id, "RefID"
    )
    SELECT ods_id, "RefID" FROM odins."DIM_Клиенты" FOR UPDATE;

    GET DIAGNOSTICS var_rowcount = ROW_COUNT;
    par_rowcount := par_rowcount + var_rowcount;

    IF var_rowcount > 0 THEN
        INSERT INTO dwh_processing_details( dwh_session_id, schema_name, table_name, row_count)
        SELECT par_dwh_session_id, 'odins', 'DIM_Клиенты',var_rowcount;
    END IF;

    DELETE FROM odins."DIM_Клиенты_history" WHERE dwh_session_id = par_dwh_session_id;

    INSERT INTO odins."DIM_Клиенты_history"(
        nkey,
        dwh_session_id,
        "RefID",
        "DeletionMark",
        "Code",
        "Description",
        "Контакт",
        dt_create
    )
    SELECT
        b.nkey,
        par_dwh_session_id AS dwh_session_id,
        b."RefID",
        b."DeletionMark",
        b."Code",
        b."Description",
        b."Контакт",
        now() AS dt_create
    FROM odins."DIM_Клиенты" b
        INNER JOIN "tmp_DIM_Клиенты" ll ON b.ods_id = ll.ods_id;

    COMMIT;
--DIM_Товары
    LOCK TABLE odins."DIM_Товары" IN ROW EXCLUSIVE MODE;
    DROP TABLE IF EXISTS "tmp_DIM_Товары";
    CREATE TEMPORARY TABLE "tmp_DIM_Товары"(
        ods_id bigint Primary Key,
        "RefID" uuid
    );
    INSERT INTO "tmp_DIM_Товары" (
        ods_id, "RefID"
    )
    SELECT ods_id, "RefID" FROM odins."DIM_Товары" FOR UPDATE;

    GET DIAGNOSTICS var_rowcount = ROW_COUNT;
    par_rowcount := par_rowcount + var_rowcount;

    IF var_rowcount > 0 THEN
        INSERT INTO dwh_processing_details( dwh_session_id, schema_name, table_name, row_count)
        SELECT par_dwh_session_id, 'odins', 'DIM_Товары',var_rowcount;
    END IF;

    DELETE FROM odins."DIM_Товары_history" WHERE dwh_session_id = par_dwh_session_id;

    INSERT INTO odins."DIM_Товары_history"(
        nkey,
        dwh_session_id,
        "RefID",
        "DeletionMark",
        "Code",
        "Description",
        "Описание",
        dt_create
    )
    SELECT
        b.nkey,
        par_dwh_session_id AS dwh_session_id,
        b."RefID",
        b."DeletionMark",
        b."Code",
        b."Description",
        b."Описание",
        now() AS dt_create
    FROM odins."DIM_Товары" b
        INNER JOIN "tmp_DIM_Товары" ll ON b.ods_id = ll.ods_id;

    COMMIT;
--FACT_Продажи
    LOCK TABLE odins."FACT_Продажи" IN ROW EXCLUSIVE MODE;
    DROP TABLE IF EXISTS "tmp_FACT_Продажи";
    CREATE TEMPORARY TABLE "tmp_FACT_Продажи"(
        ods_id bigint Primary Key,
        "RefID" uuid
    );
    INSERT INTO "tmp_FACT_Продажи" (
        ods_id, "RefID"
    )
    SELECT ods_id, "RefID" FROM odins."FACT_Продажи" FOR UPDATE;

    GET DIAGNOSTICS var_rowcount = ROW_COUNT;
    par_rowcount := par_rowcount + var_rowcount;

    IF var_rowcount > 0 THEN
        INSERT INTO dwh_processing_details( dwh_session_id, schema_name, table_name, row_count)
        SELECT par_dwh_session_id, 'odins', 'FACT_Продажи',var_rowcount;
    END IF;

    DELETE FROM odins."FACT_Продажи_history" WHERE dwh_session_id = par_dwh_session_id;

    INSERT INTO odins."FACT_Продажи_history"(
        nkey,
        dwh_session_id,
        "RefID",
        "DeletionMark",
        "Number",
        "Posted",
        "Date",
        "ДатаОтгрузки",
        "Клиент",
        "ТипДоставки",
        "ПримерСоставногоТипа",
        "ПримерСоставногоТипа_ТипЗначения",
        dt_create
    )
    SELECT
        b.nkey,
        par_dwh_session_id AS dwh_session_id,
        b."RefID",
        b."DeletionMark",
        b."Number",
        b."Posted",
        b."Date",
        b."ДатаОтгрузки",
        b."Клиент",
        b."ТипДоставки",
        b."ПримерСоставногоТипа",
        b."ПримерСоставногоТипа_ТипЗначения",
        now() AS dt_create
    FROM odins."FACT_Продажи" b
        INNER JOIN "tmp_FACT_Продажи" ll ON b.ods_id = ll.ods_id;


    DELETE FROM odins."FACT_Продажи_Товары_history" WHERE dwh_session_id = par_dwh_session_id;

    INSERT INTO odins."FACT_Продажи_Товары_history"(
        nkey,
        dwh_session_id,
        "FACT_ПродажиRefID",
        "Доставка",
        "Товар",
        "Колличество",
        "Цена",
        dt_create
    )
    SELECT
        b.nkey,
        par_dwh_session_id AS dwh_session_id,
        b."FACT_ПродажиRefID",
        b."Доставка",
        b."Товар",
        b."Колличество",
        b."Цена",
        now() AS dt_create
    FROM odins."FACT_Продажи_Товары" b
        INNER JOIN "tmp_FACT_Продажи" ll ON b."FACT_ПродажиRefID" = ll."RefID";


    GET DIAGNOSTICS var_rowcount = ROW_COUNT;
    par_rowcount := par_rowcount + var_rowcount;

    IF var_rowcount > 0 THEN
        INSERT INTO dwh_processing_details( dwh_session_id, schema_name, table_name, row_count)
        SELECT par_dwh_session_id, 'odins', 'FACT_Продажи_Товары',var_rowcount;
    END IF;

    COMMIT;

   -- Deleted and create session
    IF par_rowcount > 0 THEN
        -- Delete star: odins.DIM_Валюты
        DELETE FROM odins."DIM_Валюты" AS b
        USING "tmp_DIM_Валюты" AS ll
        WHERE b.ods_id = ll.ods_id;
            -- Delete child: odins.DIM_Валюты.Представления
            DELETE FROM odins."DIM_Валюты_Представления" AS b
            USING "tmp_DIM_Валюты" AS ll
            WHERE b."DIM_ВалютыRefID" = ll."RefID";
        -- Delete star: odins.DIM_Клиенты
        DELETE FROM odins."DIM_Клиенты" AS b
        USING "tmp_DIM_Клиенты" AS ll
        WHERE b.ods_id = ll.ods_id;
        -- Delete star: odins.DIM_Товары
        DELETE FROM odins."DIM_Товары" AS b
        USING "tmp_DIM_Товары" AS ll
        WHERE b.ods_id = ll.ods_id;
        -- Delete star: odins.FACT_Продажи
        DELETE FROM odins."FACT_Продажи" AS b
        USING "tmp_FACT_Продажи" AS ll
        WHERE b.ods_id = ll.ods_id;
            -- Delete child: odins.FACT_Продажи.Товары
            DELETE FROM odins."FACT_Продажи_Товары" AS b
            USING "tmp_FACT_Продажи" AS ll
            WHERE b."FACT_ПродажиRefID" = ll."RefID";
        CALL public."dwh_SaveSessionState" (par_dwh_session_id::bigint, 1::smallint, 2::smallint, null) ;
    END IF;

    SELECT create_session INTO par_create_session FROM dwh_session WHERE dwh_session_id = par_dwh_session_id;
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE "dwh_SaveSessionState"';
END;
$$;
/*
call "dwh_SaveSessionState" (par_dwh_session_id =1, par_data_source_id =1, par_dwh_session_state_id=1, par_error_message 'ok' ) 
call public."dwh_SaveSessionState" (null::bigint, 1::smallint, 1::smallint, 'ok'::varchar(4000) ) 
call public."dwh_SaveSessionState" (1::bigint, 1::smallint, 1::smallint, 'ok'::varchar(4000) ) 
SELECT * FROM dwh_session
*/
CREATE OR REPLACE PROCEDURE "dwh_SaveSessionState" (
    par_dwh_session_id inout bigint DEFAULT NULL, 
    par_data_source_id in smallint DEFAULT NULL, 
    par_dwh_session_state_id in smallint DEFAULT NULL, 
    par_error_message in varchar(4000) DEFAULT NULL 
)
AS $BODY$
DECLARE
    var_RowCount int;
BEGIN

    IF par_dwh_session_id IS NULL THEN
    
        SELECT  MAX(dwh_session_id) into par_dwh_session_id FROM dwh_session WHERE dwh_session_state_id = 1;
        IF NOT par_dwh_session_id IS NULL THEN
            RETURN;
        END IF;    

        INSERT INTO dwh_session (data_source_id,    dwh_session_state_id,    error_message)
        VALUES(par_data_source_id, par_dwh_session_state_id, par_error_message);
        
        SELECT currval(pg_get_serial_sequence('dwh_session','dwh_session_id')) into par_dwh_session_id;
        RETURN;
    
    ELSE
    
        UPDATE dwh_session SET 
                dwh_session_state_id = par_dwh_session_state_id,    
                error_message = par_error_message,
                create_session = CASE WHEN par_dwh_session_state_id = 2 THEN now() ELSE create_session END,
                dt_update = now()
        WHERE dwh_session_id = par_dwh_session_id;
    END IF;

END;

$BODY$
LANGUAGE plpgsql;
    
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE "load_metadata"';
END;
$$;
-- CALL load_metadata(NULL,NULL);
CREATE OR REPLACE PROCEDURE "load_metadata" (
    IN par_session_id bigint DEFAULT NULL::bigint,
    IN par_buffer_history_mode smallint DEFAULT (0)::smallint,
    INOUT par_rowcount integer DEFAULT NULL::integer,
    INOUT par_errmessage character varying DEFAULT NULL::character varying(4000)
)
AS $BODY$
DECLARE
    var_RowCount int;
    var_mindate timestamp without time zone;
    var_updatedate timestamp without time zone;
    var_bufferhistorydays int;
    var_err_session_id bigint;
    var_buffer_history_mode smallint;

BEGIN
    var_buffer_history_mode := CASE WHEN par_buffer_history_mode IS NULL OR par_buffer_history_mode > 2 THEN 2 ELSE par_buffer_history_mode END;
    SELECT now() INTO var_updatedate;
    SELECT now() INTO var_updatedate;
    SELECT to_date('19000101', 'YYYYMMDD') INTO var_mindate;
    SELECT (CASE WHEN (par_buffer_history_mode = 2) THEN 10 ELSE 30 END) INTO var_bufferhistorydays;

    DROP TABLE IF EXISTS "metadata_tmp1";
    CREATE TEMPORARY TABLE "metadata_tmp1" (
        buffer_id int,
        "namespace_ver" varchar(256)
    );
    LOCK TABLE metadata_buffer IN ROW EXCLUSIVE MODE;

    INSERT INTO "metadata_tmp1" (
        SELECT buffer_id,
        CAST(msg as json)->'Реквизиты'->0->>'ПространствоИменСВерсией' AS "namespace_ver"
        FROM "metadata_buffer" b
        WHERE b."is_error" = false FOR UPDATE
    );
    GET DIAGNOSTICS var_rowcount = ROW_COUNT;
    par_rowcount := var_rowcount;

    IF var_rowcount = 0 THEN
        return;
    END IF;
    BEGIN
        DROP TABLE IF EXISTS "metadata_tmp2";
        CREATE TEMPORARY TABLE "metadata_tmp2" (
            nkey uuid NOT NULL,
            namespace character varying(256) ,
            namespace_ver character varying(256) ,
            msg text ,
            type character varying(128) ,
            dt_create timestamp with time zone NOT NULL,
            CONSTRAINT "PK_metadata" PRIMARY KEY (nkey)
        );

        INSERT INTO "metadata_tmp2" (
        SELECT 
            CAST(md5(CONVERT(
                (CAST(msg as json)->'Реквизиты'->0->>'ПространствоИменСВерсией')
                ::bytea,'UTF8','UHC')) AS UUID) AS  nkey,

            CAST(msg as json)->'Реквизиты'->0->>'ПространствоИменИсходное' AS "namespace",
            CAST(msg as json)->'Реквизиты'->0->>'ПространствоИменСВерсией' AS "namespace_ver",
            msg, 'json' as type, now()
            FROM "metadata_buffer" b
                INNER JOIN (SELECT MAX(buffer_id) AS buffer_id FROM metadata_tmp1 GROUP BY namespace_ver ) t ON b.buffer_id = t.buffer_id
            WHERE b."is_error" = false 
        );

        UPDATE metadata AS t SET
            namespace = b.namespace,
            namespace_ver = b.namespace_ver,
            msg = b.msg,
            type = b.type
         FROM metadata_tmp2 b
         WHERE 
            b.nkey = t.nkey;


        INSERT INTO metadata (
            SELECT b.* FROM metadata_tmp2 b
            WHERE NOT EXISTS (SELECT 1 FROM metadata t WHERE b.nkey = t.nkey )
        );

        DELETE 
        FROM metadata_buffer as trg
        USING metadata_tmp1 AS tmp
        WHERE trg.buffer_id = tmp.buffer_id;

            -- Clear buffer table
        IF var_buffer_history_mode = 1 AND NOT EXISTS (SELECT 1 FROM metadata_buffer WHERE is_error = true) THEN
    
            DELETE FROM metadata_buffer AS org 
                USING "metadata_tmp1" AS src
            WHERE org."buffer_id" = src."buffer_id";
    
        ELSE
            
            UPDATE metadata_buffer AS org SET
                dt_update = var_updatedate
            FROM "metadata_tmp1" AS src 
            WHERE org."buffer_id" = src."buffer_id" ;
        
            IF var_buffer_history_mode >= 2 AND NOT EXISTS (SELECT 1 FROM metadata_buffer WHERE is_error = true) THEN
                DELETE 
                FROM metadata_buffer AS b
                WHERE EXTRACT(DAY FROM  var_updatedate::timestamp - dt_update::timestamp) > var_bufferhistorydays;
            END IF;
        END    IF;

    EXCEPTION WHEN OTHERS -- аналог catch  
    THEN
        GET STACKED DIAGNOSTICS
        par_errmessage = MESSAGE_TEXT;
    
        SELECT COALESCE(par_session_id, 0) INTO var_err_session_id;
        INSERT INTO session_log (session_id, session_state_id, error_message)
        SELECT var_err_session_id,
            3 AS session_state_id,
            'Table metadata_buffer. Error: ' || par_errmessage AS error_message;

        UPDATE metadata_buffer AS org SET
            is_error  = true,
            dt_update = var_updatedate
        FROM "metadata_tmp1" AS src 
        WHERE org."buffer_id" = src."buffer_id" ;
    
    END;
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE public."rb_SaveSessionState"';

END;
$$;

CREATE OR REPLACE PROCEDURE public."rb_SaveSessionState" (
    par_session_id inout bigint DEFAULT NULL, 
    par_data_source_id in smallint = 1,
    par_session_state_id in smallint = 1,
    par_error_message in varchar(4000) DEFAULT NULL 
)
AS $BODY$
BEGIN
    IF par_session_id IS NULL THEN

        INSERT INTO "session" (data_source_id, session_state_id, error_message)
        VALUES(par_data_source_id, par_session_state_id, par_error_message);
        
        SELECT currval(pg_get_serial_sequence('session', 'session_id')) INTO par_session_id;
        RETURN;
    ELSE
        UPDATE "session"
        SET data_source_id = par_data_source_id,
            session_state_id = par_session_state_id,
            dt_update = now()
        WHERE session_id = par_session_id;
    END IF;
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'Create table DIM_Валюты_buffer';
END;
$$;
CREATE TABLE IF NOT EXISTS odins."DIM_Валюты_buffer" (
    "buffer_id"   bigint   NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    "session_id"  bigint   NOT NULL,
    "msg_id"      uuid     NOT NULL,
    "msg"         text     NULL,
    "is_error"    boolean  NOT NULL DEFAULT false,
    "msgtype_id"  smallint NOT NULL DEFAULT 1,
    "dt_create"   timestamp without time zone NOT NULL  default now(),
    "dt_update"   timestamp without time zone NOT NULL  default to_date('19000101', 'YYYYMMDD')
);
do
$$
BEGIN
RAISE NOTICE 'Create table DIM_Валюты_history';
END;
$$;
CREATE TABLE IF NOT EXISTS "odins"."DIM_Валюты_history" (
    nkey              uuid NOT NULL,
    dwh_session_id    bigint,
    "RefID"            uuid  NULL,
    "DeletionMark"            boolean  NULL,
    "Code"            varchar(128)  NULL,
    "Description"            varchar(128)  NULL,
    "ЗагружаетсяИзИнтернета"            boolean  NULL,
    "НаименованиеПолное"            varchar(50)  NULL,
    "Наценка"            decimal(10, 2)  NULL,
    "ОсновнаяВалюта"            varchar(36)  NULL,
    "ПараметрыПрописи"            varchar(200)  NULL,
    "ФормулаРасчетаКурса"            varchar(100)  NULL,
    "СпособУстановкиКурса"            varchar(500)  NULL,
    "dt_create"              timestamp without time zone         NULL default now());
do
$$
BEGIN
RAISE NOTICE 'Create table DIM_Валюты';
END;
$$;

CREATE TABLE IF NOT EXISTS odins."DIM_Валюты" (
    ods_id        bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) PRIMARY KEY,
    nkey          uuid NOT NULL,
    "RefID"        uuid  NOT NULL  ,
    "DeletionMark"        boolean   NULL  ,
    "Code"        varchar(128)   NULL  ,
    "Description"        varchar(128)   NULL  ,
    "ЗагружаетсяИзИнтернета"        boolean   NULL  ,
    "НаименованиеПолное"        varchar(50)   NULL  ,
    "Наценка"        decimal(10, 2)   NULL  ,
    "ОсновнаяВалюта"        varchar(36)   NULL  ,
    "ПараметрыПрописи"        varchar(200)   NULL  ,
    "ФормулаРасчетаКурса"        varchar(100)   NULL  ,
    "СпособУстановкиКурса"        varchar(500)   NULL  ,
    dt_update     timestamp without time zone default now(),
    dt_create     timestamp without time zone default now()
);

COMMENT ON TABLE "odins"."DIM_Валюты" IS '{"Description":"DIM_Валюты"}';

CREATE UNIQUE INDEX IF NOT EXISTS "IDX_odins_DIM_Валюты" ON odins."DIM_Валюты" (nkey);
do
$$
BEGIN
RAISE NOTICE 'Create table DIM_Валюты_Представления_history';
END;
$$;
CREATE TABLE IF NOT EXISTS "odins"."DIM_Валюты_Представления_history" (
    nkey              uuid NOT NULL,
    dwh_session_id    bigint,
    "DIM_ВалютыRefID"            uuid  NULL,
    "КодЯзыка"            varchar(10)  NULL,
    "ПараметрыПрописи"            varchar(200)  NULL,
    "dt_create"              timestamp without time zone         NULL default now());
do
$$
BEGIN
RAISE NOTICE 'Create table DIM_Валюты_Представления';
END;
$$;

CREATE TABLE IF NOT EXISTS odins."DIM_Валюты_Представления" (
    ods_id        bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) PRIMARY KEY,
    nkey          uuid NOT NULL,
    "DIM_ВалютыRefID"        uuid  NOT NULL  ,
    "КодЯзыка"        varchar(10)   NULL  ,
    "ПараметрыПрописи"        varchar(200)   NULL  ,
    dt_update     timestamp without time zone default now(),
    dt_create     timestamp without time zone default now()
);

COMMENT ON TABLE "odins"."DIM_Валюты_Представления" IS '{"Description":"DIM_Валюты.Представления"}';

CREATE UNIQUE INDEX IF NOT EXISTS "IDX_odins_DIM_Валюты_Представления" ON odins."DIM_Валюты_Представления" (nkey);
do
$$
BEGIN
RAISE NOTICE 'Create table DIM_Клиенты_buffer';
END;
$$;
CREATE TABLE IF NOT EXISTS odins."DIM_Клиенты_buffer" (
    "buffer_id"   bigint   NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    "session_id"  bigint   NOT NULL,
    "msg_id"      uuid     NOT NULL,
    "msg"         text     NULL,
    "is_error"    boolean  NOT NULL DEFAULT false,
    "msgtype_id"  smallint NOT NULL DEFAULT 1,
    "dt_create"   timestamp without time zone NOT NULL  default now(),
    "dt_update"   timestamp without time zone NOT NULL  default to_date('19000101', 'YYYYMMDD')
);
do
$$
BEGIN
RAISE NOTICE 'Create table DIM_Клиенты_history';
END;
$$;
CREATE TABLE IF NOT EXISTS "odins"."DIM_Клиенты_history" (
    nkey              uuid NOT NULL,
    dwh_session_id    bigint,
    "RefID"            uuid  NULL,
    "DeletionMark"            boolean  NULL,
    "Code"            varchar(128)  NULL,
    "Description"            varchar(128)  NULL,
    "Контакт"            varchar(500)  NULL,
    "dt_create"              timestamp without time zone         NULL default now());
do
$$
BEGIN
RAISE NOTICE 'Create table DIM_Клиенты';
END;
$$;

CREATE TABLE IF NOT EXISTS odins."DIM_Клиенты" (
    ods_id        bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) PRIMARY KEY,
    nkey          uuid NOT NULL,
    "RefID"        uuid  NOT NULL  ,
    "DeletionMark"        boolean   NULL  ,
    "Code"        varchar(128)   NULL  ,
    "Description"        varchar(128)   NULL  ,
    "Контакт"        varchar(500)   NULL  ,
    dt_update     timestamp without time zone default now(),
    dt_create     timestamp without time zone default now()
);

COMMENT ON TABLE "odins"."DIM_Клиенты" IS '{"Description":"DIM_Клиенты"}';

CREATE UNIQUE INDEX IF NOT EXISTS "IDX_odins_DIM_Клиенты" ON odins."DIM_Клиенты" (nkey);
do
$$
BEGIN
RAISE NOTICE 'Create table DIM_Товары_buffer';
END;
$$;
CREATE TABLE IF NOT EXISTS odins."DIM_Товары_buffer" (
    "buffer_id"   bigint   NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    "session_id"  bigint   NOT NULL,
    "msg_id"      uuid     NOT NULL,
    "msg"         text     NULL,
    "is_error"    boolean  NOT NULL DEFAULT false,
    "msgtype_id"  smallint NOT NULL DEFAULT 1,
    "dt_create"   timestamp without time zone NOT NULL  default now(),
    "dt_update"   timestamp without time zone NOT NULL  default to_date('19000101', 'YYYYMMDD')
);
do
$$
BEGIN
RAISE NOTICE 'Create table DIM_Товары_history';
END;
$$;
CREATE TABLE IF NOT EXISTS "odins"."DIM_Товары_history" (
    nkey              uuid NOT NULL,
    dwh_session_id    bigint,
    "RefID"            uuid  NULL,
    "DeletionMark"            boolean  NULL,
    "Code"            varchar(128)  NULL,
    "Description"            varchar(128)  NULL,
    "Описание"            varchar(255)  NULL,
    "dt_create"              timestamp without time zone         NULL default now());
do
$$
BEGIN
RAISE NOTICE 'Create table DIM_Товары';
END;
$$;

CREATE TABLE IF NOT EXISTS odins."DIM_Товары" (
    ods_id        bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) PRIMARY KEY,
    nkey          uuid NOT NULL,
    "RefID"        uuid  NOT NULL  ,
    "DeletionMark"        boolean   NULL  ,
    "Code"        varchar(128)   NULL  ,
    "Description"        varchar(128)   NULL  ,
    "Описание"        varchar(255)   NULL  ,
    dt_update     timestamp without time zone default now(),
    dt_create     timestamp without time zone default now()
);

COMMENT ON TABLE "odins"."DIM_Товары" IS '{"Description":"DIM_Товары"}';

CREATE UNIQUE INDEX IF NOT EXISTS "IDX_odins_DIM_Товары" ON odins."DIM_Товары" (nkey);
do
$$
BEGIN
RAISE NOTICE 'Create table FACT_Продажи_buffer';
END;
$$;
CREATE TABLE IF NOT EXISTS odins."FACT_Продажи_buffer" (
    "buffer_id"   bigint   NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    "session_id"  bigint   NOT NULL,
    "msg_id"      uuid     NOT NULL,
    "msg"         text     NULL,
    "is_error"    boolean  NOT NULL DEFAULT false,
    "msgtype_id"  smallint NOT NULL DEFAULT 1,
    "dt_create"   timestamp without time zone NOT NULL  default now(),
    "dt_update"   timestamp without time zone NOT NULL  default to_date('19000101', 'YYYYMMDD')
);
do
$$
BEGIN
RAISE NOTICE 'Create table FACT_Продажи_history';
END;
$$;
CREATE TABLE IF NOT EXISTS "odins"."FACT_Продажи_history" (
    nkey              uuid NOT NULL,
    dwh_session_id    bigint,
    "RefID"            uuid  NULL,
    "DeletionMark"            boolean  NULL,
    "Number"            integer  NULL,
    "Posted"            boolean  NULL,
    "Date"            timestamp  NULL,
    "ДатаОтгрузки"            timestamp  NULL,
    "Клиент"            varchar(36)  NULL,
    "ТипДоставки"            varchar(500)  NULL,
    "ПримерСоставногоТипа"            varchar(36)  NULL,
    "ПримерСоставногоТипа_ТипЗначения"            varchar(128)  NULL,
    "dt_create"              timestamp without time zone         NULL default now());
do
$$
BEGIN
RAISE NOTICE 'Create table FACT_Продажи';
END;
$$;

CREATE TABLE IF NOT EXISTS odins."FACT_Продажи" (
    ods_id        bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) PRIMARY KEY,
    nkey          uuid NOT NULL,
    "RefID"        uuid  NOT NULL  ,
    "DeletionMark"        boolean   NULL  ,
    "Number"        integer   NULL  ,
    "Posted"        boolean   NULL  ,
    "Date"        timestamp   NULL  ,
    "ДатаОтгрузки"        timestamp   NULL  ,
    "Клиент"        varchar(36)   NULL  ,
    "ТипДоставки"        varchar(500)   NULL  ,
    "ПримерСоставногоТипа"        varchar(36)   NULL  ,
    "ПримерСоставногоТипа_ТипЗначения"        varchar(128)   NULL  ,
    dt_update     timestamp without time zone default now(),
    dt_create     timestamp without time zone default now()
);

COMMENT ON TABLE "odins"."FACT_Продажи" IS '{"Description":"FACT_Продажи"}';

CREATE UNIQUE INDEX IF NOT EXISTS "IDX_odins_FACT_Продажи" ON odins."FACT_Продажи" (nkey);
do
$$
BEGIN
RAISE NOTICE 'Create table FACT_Продажи_Товары_history';
END;
$$;
CREATE TABLE IF NOT EXISTS "odins"."FACT_Продажи_Товары_history" (
    nkey              uuid NOT NULL,
    dwh_session_id    bigint,
    "FACT_ПродажиRefID"            uuid  NULL,
    "Доставка"            boolean  NULL,
    "Товар"            varchar(36)  NULL,
    "Колличество"            decimal(12, 0)  NULL,
    "Цена"            decimal(16, 4)  NULL,
    "dt_create"              timestamp without time zone         NULL default now());
do
$$
BEGIN
RAISE NOTICE 'Create table FACT_Продажи_Товары';
END;
$$;

CREATE TABLE IF NOT EXISTS odins."FACT_Продажи_Товары" (
    ods_id        bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) PRIMARY KEY,
    nkey          uuid NOT NULL,
    "FACT_ПродажиRefID"        uuid  NOT NULL  ,
    "Доставка"        boolean   NULL  ,
    "Товар"        varchar(36)   NULL  ,
    "Колличество"        decimal(12, 0)   NULL  ,
    "Цена"        decimal(16, 4)   NULL  ,
    dt_update     timestamp without time zone default now(),
    dt_create     timestamp without time zone default now()
);

COMMENT ON TABLE "odins"."FACT_Продажи_Товары" IS '{"Description":"FACT_Продажи.Товары"}';

CREATE UNIQUE INDEX IF NOT EXISTS "IDX_odins_FACT_Продажи_Товары" ON odins."FACT_Продажи_Товары" (nkey);
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE odins."load_DIM_Валюты_file"';
END;
$$;

CREATE OR REPLACE PROCEDURE odins."load_DIM_Валюты_file" (
    par_session_id in bigint DEFAULT NULL, 
    par_rowcount inout int DEFAULT NULL 
)
AS $BODY$
DECLARE
    var_rowcount int;
BEGIN

    DROP TABLE IF EXISTS "DIM_Валюты_tmp1";
    
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE odins."load_DIM_Валюты_staging"';
END;
$$;

CREATE OR REPLACE PROCEDURE odins."load_DIM_Валюты_staging" (
    par_session_id in bigint DEFAULT NULL, 
    par_rowcount inout int DEFAULT NULL 
)
AS $BODY$
DECLARE
    var_rowcount int;
BEGIN

    DROP TABLE IF EXISTS "DIM_Валюты_tmp1";

END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE odins."load_DIM_Валюты"';
END;
$$;

--CALL odins."load_DIM_Валюты"(NULL::bigint, 1::smallint, NULL::integer, NULL::varchar(4000))
CREATE OR REPLACE PROCEDURE odins."load_DIM_Валюты" (
    IN par_session_id bigint DEFAULT NULL,
    IN par_buffer_history_mode smallint DEFAULT 2::smallint,  -- 0 - Do not delete the buffering history.
                                                              -- 1 - Delete the buffering history.
                                                              -- 2 - Keep the buffering history for 10 days.
                                                              -- 3 - Keep the buffering history for a month.
    INOUT par_rowcount integer DEFAULT NULL::integer,
    INOUT par_errmessage varchar(4000) DEFAULT NULL::varchar(4000)
)
AS $BODY$
DECLARE
    var_rowcount integer;
    var_xmlns text ARRAY;
    var_mindate timestamp without time zone;
    var_updatedate timestamp without time zone;
    var_bufferhistorydays int;
    var_err_session_id bigint;
    var_buffer_history_mode smallint;
BEGIN
    var_buffer_history_mode := CASE WHEN par_buffer_history_mode IS NULL OR par_buffer_history_mode > 2 THEN 2 ELSE par_buffer_history_mode END;
    SELECT now() INTO var_updatedate;
    SELECT to_date('19000101', 'YYYYMMDD') INTO var_mindate;
    SELECT (CASE WHEN (par_buffer_history_mode = 2) THEN 10 ELSE 30 END) INTO var_bufferhistorydays;

    SELECT ARRAY[ARRAY['nva', 'http://v8.1c.ru/8.1/data/enterprise/current-config'], ARRAY['xsi', 'http://www.w3.org/2001/XMLSchema-instance'], ARRAY['xs', 'http://www.w3.org/2001/XMLSchema']] into var_xmlns;

    DROP TABLE IF EXISTS "DIM_Валюты_lock";
    CREATE TEMPORARY TABLE "DIM_Валюты_lock" (
        "buffer_id" int,
        "RefID" uuid
    );

    DROP TABLE IF EXISTS "DIM_Валюты_tmp1";
    CREATE TEMPORARY TABLE "DIM_Валюты_tmp1" (
        "buffer_id" int,
        "RefID" uuid
    );

    INSERT INTO "DIM_Валюты_lock" (buffer_id, "RefID")
    SELECT buffer_id AS buffer_id,
        CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Клиенты/nva:Ref/text()', msg::xml, var_xmlns ))[1]::text as uuid) ref
    FROM "odins"."DIM_Валюты_buffer" b
    WHERE b.dt_update = var_mindate;

    GET DIAGNOSTICS var_rowcount = ROW_COUNT;
    par_rowcount := var_rowcount;

    IF var_rowcount = 0 THEN
        RETURN;
    END IF;

    BEGIN
        INSERT INTO "DIM_Валюты_tmp1" (buffer_id, "RefID")
        SELECT MAX(buffer_id) AS buffer_id,
            "RefID"
        FROM "DIM_Валюты_lock" b
        GROUP BY "RefID";

        GET DIAGNOSTICS var_rowcount = ROW_COUNT;
        par_rowcount := var_rowcount;

        DROP TABLE IF EXISTS "DIM_Валюты_tmp2";
        CREATE TEMPORARY TABLE "DIM_Валюты_tmp2" (
            "nkey" uuid,
            "DIM_Валюты_Представления"  xml,
            "RefID" uuid,
            "DeletionMark" boolean,
            "Code" varchar(128),
            "Description" varchar(128),
            "ЗагружаетсяИзИнтернета" boolean,
            "НаименованиеПолное" varchar(50),
            "Наценка" decimal(10, 2),
            "ОсновнаяВалюта" varchar(36),
            "ПараметрыПрописи" varchar(200),
            "ФормулаРасчетаКурса" varchar(100),
            "СпособУстановкиКурса" varchar(500),
            "dt_update" timestamp without time zone 
        );

        INSERT INTO "DIM_Валюты_tmp2"
        (
        SELECT
            CAST(md5(CONVERT(
                    CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:Ref/text()', msg::xml, var_xmlns ))[1] as VARCHAR)                    
                    ::bytea,'UTF8','UHC')) AS UUID) AS "nkey",

            (xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:DIM_Валюты.Представления/text()', msg::xml, var_xmlns ))[1]::xml  AS "DIM_Валюты_Представления",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:Ref/text()', msg::xml, var_xmlns ))[1]::text as uuid)  AS "RefID",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:DeletionMark/text()', msg::xml, var_xmlns ))[1]::text as boolean)  AS "DeletionMark",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:Code/text()', msg::xml, var_xmlns ))[1]::text as varchar(128))  AS "Code",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:Description/text()', msg::xml, var_xmlns ))[1]::text as varchar(128))  AS "Description",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:ЗагружаетсяИзИнтернета/text()', msg::xml, var_xmlns ))[1]::text as boolean)  AS "ЗагружаетсяИзИнтернета",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:НаименованиеПолное/text()', msg::xml, var_xmlns ))[1]::text as varchar(50))  AS "НаименованиеПолное",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:Наценка/text()', msg::xml, var_xmlns ))[1]::text as decimal(10, 2))  AS "Наценка",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:ОсновнаяВалюта/text()', msg::xml, var_xmlns ))[1]::text as varchar(36))  AS "ОсновнаяВалюта",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:ПараметрыПрописи/text()', msg::xml, var_xmlns ))[1]::text as varchar(200))  AS "ПараметрыПрописи",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:ФормулаРасчетаКурса/text()', msg::xml, var_xmlns ))[1]::text as varchar(100))  AS "ФормулаРасчетаКурса",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:СпособУстановкиКурса/text()', msg::xml, var_xmlns ))[1]::text as varchar(500))  AS "СпособУстановкиКурса",
            CAST(now() as timestamp without time zone) 
        FROM "odins"."DIM_Валюты_buffer" AS b
        WHERE b."is_error" = false AND EXISTS (SELECT 1 FROM "DIM_Валюты_tmp1" AS t WHERE CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Валюты/nva:Ref/text()', msg::xml, var_xmlns ))[1]::text as uuid) = t."RefID" AND b.buffer_id = t.buffer_id )
        );

        UPDATE "odins"."DIM_Валюты" AS org SET
            "nkey" = src."nkey",
            "RefID" = src."RefID",
            "DeletionMark" = src."DeletionMark",
            "Code" = src."Code",
            "Description" = src."Description",
            "ЗагружаетсяИзИнтернета" = src."ЗагружаетсяИзИнтернета",
            "НаименованиеПолное" = src."НаименованиеПолное",
            "Наценка" = src."Наценка",
            "ОсновнаяВалюта" = src."ОсновнаяВалюта",
            "ПараметрыПрописи" = src."ПараметрыПрописи",
            "ФормулаРасчетаКурса" = src."ФормулаРасчетаКурса",
            "СпособУстановкиКурса" = src."СпособУстановкиКурса",
            dt_update = var_updatedate
        FROM "DIM_Валюты_tmp2" AS src 
        WHERE org."nkey" = src."nkey" ;

        INSERT INTO "odins"."DIM_Валюты" (
            "nkey" ,
            "RefID",
            "DeletionMark",
            "Code",
            "Description",
            "ЗагружаетсяИзИнтернета",
            "НаименованиеПолное",
            "Наценка",
            "ОсновнаяВалюта",
            "ПараметрыПрописи",
            "ФормулаРасчетаКурса",
            "СпособУстановкиКурса",
            dt_update
        )
        SELECT 
            src."nkey" ,
            src."RefID",
            src."DeletionMark",
            src."Code",
            src."Description",
            src."ЗагружаетсяИзИнтернета",
            src."НаименованиеПолное",
            src."Наценка",
            src."ОсновнаяВалюта",
            src."ПараметрыПрописи",
            src."ФормулаРасчетаКурса",
            src."СпособУстановкиКурса",
            src."dt_update"
         FROM "DIM_Валюты_tmp2" AS src 
            LEFT JOIN "odins"."DIM_Валюты" AS org ON org."nkey" = src."nkey" 
         WHERE org."RefID" IS NULL ;


        -- Clear buffer table
        IF var_buffer_history_mode = 1 AND NOT EXISTS (SELECT 1 FROM "odins"."DIM_Валюты_buffer" WHERE is_error = true) THEN

            DELETE FROM "odins"."DIM_Валюты_buffer" AS org
                USING "DIM_Валюты_lock" AS src
            WHERE org."buffer_id" = src."buffer_id";

        ELSE

            UPDATE "odins"."DIM_Валюты_buffer" AS org SET
                dt_update = var_updatedate
            FROM "DIM_Валюты_lock" AS src
            WHERE org."buffer_id" = src."buffer_id";

            IF var_buffer_history_mode >= 2 AND NOT EXISTS (SELECT 1 FROM "odins"."DIM_Валюты_buffer" WHERE is_error = true) THEN
                DELETE
                FROM "odins"."DIM_Валюты_buffer" AS b
                WHERE EXTRACT(DAY FROM var_updatedate::timestamp - dt_update::timestamp) > var_bufferhistorydays;
            END IF;
        END    IF;

    EXCEPTION WHEN OTHERS
    THEN
        GET STACKED DIAGNOSTICS
        par_errmessage = MESSAGE_TEXT;

        SELECT COALESCE(par_session_id, 0) INTO var_err_session_id;
        INSERT INTO session_log (session_id, session_state_id, error_message)
        SELECT var_err_session_id,
            3 AS session_state_id,
            'Table odins.DIM_Валюты. Error: ' || par_errmessage AS error_message;

        UPDATE "odins"."DIM_Валюты_buffer" AS org SET
            is_error  = true,
            dt_update = var_updatedate
        FROM "DIM_Валюты_lock" AS src
        WHERE org."buffer_id" = src."buffer_id";

    END;
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE odins."load_DIM_Клиенты_file"';
END;
$$;

CREATE OR REPLACE PROCEDURE odins."load_DIM_Клиенты_file" (
    par_session_id in bigint DEFAULT NULL, 
    par_rowcount inout int DEFAULT NULL 
)
AS $BODY$
DECLARE
    var_rowcount int;
BEGIN

    DROP TABLE IF EXISTS "DIM_Клиенты_tmp1";
    
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE odins."load_DIM_Клиенты_staging"';
END;
$$;

CREATE OR REPLACE PROCEDURE odins."load_DIM_Клиенты_staging" (
    par_session_id in bigint DEFAULT NULL, 
    par_rowcount inout int DEFAULT NULL 
)
AS $BODY$
DECLARE
    var_rowcount int;
BEGIN

    DROP TABLE IF EXISTS "DIM_Клиенты_tmp1";

END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE odins."load_DIM_Клиенты"';
END;
$$;

--CALL odins."load_DIM_Клиенты"(NULL::bigint, 1::smallint, NULL::integer, NULL::varchar(4000))
CREATE OR REPLACE PROCEDURE odins."load_DIM_Клиенты" (
    IN par_session_id bigint DEFAULT NULL,
    IN par_buffer_history_mode smallint DEFAULT 2::smallint,  -- 0 - Do not delete the buffering history.
                                                              -- 1 - Delete the buffering history.
                                                              -- 2 - Keep the buffering history for 10 days.
                                                              -- 3 - Keep the buffering history for a month.
    INOUT par_rowcount integer DEFAULT NULL::integer,
    INOUT par_errmessage varchar(4000) DEFAULT NULL::varchar(4000)
)
AS $BODY$
DECLARE
    var_rowcount integer;
    var_xmlns text ARRAY;
    var_mindate timestamp without time zone;
    var_updatedate timestamp without time zone;
    var_bufferhistorydays int;
    var_err_session_id bigint;
    var_buffer_history_mode smallint;
BEGIN
    var_buffer_history_mode := CASE WHEN par_buffer_history_mode IS NULL OR par_buffer_history_mode > 2 THEN 2 ELSE par_buffer_history_mode END;
    SELECT now() INTO var_updatedate;
    SELECT to_date('19000101', 'YYYYMMDD') INTO var_mindate;
    SELECT (CASE WHEN (par_buffer_history_mode = 2) THEN 10 ELSE 30 END) INTO var_bufferhistorydays;

    SELECT ARRAY[ARRAY['nva', 'http://v8.1c.ru/8.1/data/enterprise/current-config'], ARRAY['xsi', 'http://www.w3.org/2001/XMLSchema-instance'], ARRAY['xs', 'http://www.w3.org/2001/XMLSchema']] into var_xmlns;

    DROP TABLE IF EXISTS "DIM_Клиенты_lock";
    CREATE TEMPORARY TABLE "DIM_Клиенты_lock" (
        "buffer_id" int,
        "RefID" uuid
    );

    DROP TABLE IF EXISTS "DIM_Клиенты_tmp1";
    CREATE TEMPORARY TABLE "DIM_Клиенты_tmp1" (
        "buffer_id" int,
        "RefID" uuid
    );

    INSERT INTO "DIM_Клиенты_lock" (buffer_id, "RefID")
    SELECT buffer_id AS buffer_id,
        CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Клиенты/nva:Ref/text()', msg::xml, var_xmlns ))[1]::text as uuid) ref
    FROM "odins"."DIM_Клиенты_buffer" b
    WHERE b.dt_update = var_mindate;

    GET DIAGNOSTICS var_rowcount = ROW_COUNT;
    par_rowcount := var_rowcount;

    IF var_rowcount = 0 THEN
        RETURN;
    END IF;

    BEGIN
        INSERT INTO "DIM_Клиенты_tmp1" (buffer_id, "RefID")
        SELECT MAX(buffer_id) AS buffer_id,
            "RefID"
        FROM "DIM_Клиенты_lock" b
        GROUP BY "RefID";

        GET DIAGNOSTICS var_rowcount = ROW_COUNT;
        par_rowcount := var_rowcount;

        DROP TABLE IF EXISTS "DIM_Клиенты_tmp2";
        CREATE TEMPORARY TABLE "DIM_Клиенты_tmp2" (
            "nkey" uuid,
            "RefID" uuid,
            "DeletionMark" boolean,
            "Code" varchar(128),
            "Description" varchar(128),
            "Контакт" varchar(500),
            "dt_update" timestamp without time zone 
        );

        INSERT INTO "DIM_Клиенты_tmp2"
        (
        SELECT
            CAST(md5(CONVERT(
                    CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Клиенты/nva:Ref/text()', msg::xml, var_xmlns ))[1] as VARCHAR)                    
                    ::bytea,'UTF8','UHC')) AS UUID) AS "nkey",

            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Клиенты/nva:Ref/text()', msg::xml, var_xmlns ))[1]::text as uuid)  AS "RefID",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Клиенты/nva:DeletionMark/text()', msg::xml, var_xmlns ))[1]::text as boolean)  AS "DeletionMark",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Клиенты/nva:Code/text()', msg::xml, var_xmlns ))[1]::text as varchar(128))  AS "Code",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Клиенты/nva:Description/text()', msg::xml, var_xmlns ))[1]::text as varchar(128))  AS "Description",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Клиенты/nva:Контакт/text()', msg::xml, var_xmlns ))[1]::text as varchar(500))  AS "Контакт",
            CAST(now() as timestamp without time zone) 
        FROM "odins"."DIM_Клиенты_buffer" AS b
        WHERE b."is_error" = false AND EXISTS (SELECT 1 FROM "DIM_Клиенты_tmp1" AS t WHERE CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Клиенты/nva:Ref/text()', msg::xml, var_xmlns ))[1]::text as uuid) = t."RefID" AND b.buffer_id = t.buffer_id )
        );

        UPDATE "odins"."DIM_Клиенты" AS org SET
            "nkey" = src."nkey",
            "RefID" = src."RefID",
            "DeletionMark" = src."DeletionMark",
            "Code" = src."Code",
            "Description" = src."Description",
            "Контакт" = src."Контакт",
            dt_update = var_updatedate
        FROM "DIM_Клиенты_tmp2" AS src 
        WHERE org."nkey" = src."nkey" ;

        INSERT INTO "odins"."DIM_Клиенты" (
            "nkey" ,
            "RefID",
            "DeletionMark",
            "Code",
            "Description",
            "Контакт",
            dt_update
        )
        SELECT 
            src."nkey" ,
            src."RefID",
            src."DeletionMark",
            src."Code",
            src."Description",
            src."Контакт",
            src."dt_update"
         FROM "DIM_Клиенты_tmp2" AS src 
            LEFT JOIN "odins"."DIM_Клиенты" AS org ON org."nkey" = src."nkey" 
         WHERE org."RefID" IS NULL ;


        -- Clear buffer table
        IF var_buffer_history_mode = 1 AND NOT EXISTS (SELECT 1 FROM "odins"."DIM_Клиенты_buffer" WHERE is_error = true) THEN

            DELETE FROM "odins"."DIM_Клиенты_buffer" AS org
                USING "DIM_Клиенты_lock" AS src
            WHERE org."buffer_id" = src."buffer_id";

        ELSE

            UPDATE "odins"."DIM_Клиенты_buffer" AS org SET
                dt_update = var_updatedate
            FROM "DIM_Клиенты_lock" AS src
            WHERE org."buffer_id" = src."buffer_id";

            IF var_buffer_history_mode >= 2 AND NOT EXISTS (SELECT 1 FROM "odins"."DIM_Клиенты_buffer" WHERE is_error = true) THEN
                DELETE
                FROM "odins"."DIM_Клиенты_buffer" AS b
                WHERE EXTRACT(DAY FROM var_updatedate::timestamp - dt_update::timestamp) > var_bufferhistorydays;
            END IF;
        END    IF;

    EXCEPTION WHEN OTHERS
    THEN
        GET STACKED DIAGNOSTICS
        par_errmessage = MESSAGE_TEXT;

        SELECT COALESCE(par_session_id, 0) INTO var_err_session_id;
        INSERT INTO session_log (session_id, session_state_id, error_message)
        SELECT var_err_session_id,
            3 AS session_state_id,
            'Table odins.DIM_Клиенты. Error: ' || par_errmessage AS error_message;

        UPDATE "odins"."DIM_Клиенты_buffer" AS org SET
            is_error  = true,
            dt_update = var_updatedate
        FROM "DIM_Клиенты_lock" AS src
        WHERE org."buffer_id" = src."buffer_id";

    END;
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE odins."load_DIM_Товары_file"';
END;
$$;

CREATE OR REPLACE PROCEDURE odins."load_DIM_Товары_file" (
    par_session_id in bigint DEFAULT NULL, 
    par_rowcount inout int DEFAULT NULL 
)
AS $BODY$
DECLARE
    var_rowcount int;
BEGIN

    DROP TABLE IF EXISTS "DIM_Товары_tmp1";
    
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE odins."load_DIM_Товары_staging"';
END;
$$;

CREATE OR REPLACE PROCEDURE odins."load_DIM_Товары_staging" (
    par_session_id in bigint DEFAULT NULL, 
    par_rowcount inout int DEFAULT NULL 
)
AS $BODY$
DECLARE
    var_rowcount int;
BEGIN

    DROP TABLE IF EXISTS "DIM_Товары_tmp1";

END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE odins."load_DIM_Товары"';
END;
$$;

--CALL odins."load_DIM_Товары"(NULL::bigint, 1::smallint, NULL::integer, NULL::varchar(4000))
CREATE OR REPLACE PROCEDURE odins."load_DIM_Товары" (
    IN par_session_id bigint DEFAULT NULL,
    IN par_buffer_history_mode smallint DEFAULT 2::smallint,  -- 0 - Do not delete the buffering history.
                                                              -- 1 - Delete the buffering history.
                                                              -- 2 - Keep the buffering history for 10 days.
                                                              -- 3 - Keep the buffering history for a month.
    INOUT par_rowcount integer DEFAULT NULL::integer,
    INOUT par_errmessage varchar(4000) DEFAULT NULL::varchar(4000)
)
AS $BODY$
DECLARE
    var_rowcount integer;
    var_xmlns text ARRAY;
    var_mindate timestamp without time zone;
    var_updatedate timestamp without time zone;
    var_bufferhistorydays int;
    var_err_session_id bigint;
    var_buffer_history_mode smallint;
BEGIN
    var_buffer_history_mode := CASE WHEN par_buffer_history_mode IS NULL OR par_buffer_history_mode > 2 THEN 2 ELSE par_buffer_history_mode END;
    SELECT now() INTO var_updatedate;
    SELECT to_date('19000101', 'YYYYMMDD') INTO var_mindate;
    SELECT (CASE WHEN (par_buffer_history_mode = 2) THEN 10 ELSE 30 END) INTO var_bufferhistorydays;

    SELECT ARRAY[ARRAY['nva', 'http://v8.1c.ru/8.1/data/enterprise/current-config'], ARRAY['xsi', 'http://www.w3.org/2001/XMLSchema-instance'], ARRAY['xs', 'http://www.w3.org/2001/XMLSchema']] into var_xmlns;

    DROP TABLE IF EXISTS "DIM_Товары_lock";
    CREATE TEMPORARY TABLE "DIM_Товары_lock" (
        "buffer_id" int,
        "RefID" uuid
    );

    DROP TABLE IF EXISTS "DIM_Товары_tmp1";
    CREATE TEMPORARY TABLE "DIM_Товары_tmp1" (
        "buffer_id" int,
        "RefID" uuid
    );

    INSERT INTO "DIM_Товары_lock" (buffer_id, "RefID")
    SELECT buffer_id AS buffer_id,
        CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Клиенты/nva:Ref/text()', msg::xml, var_xmlns ))[1]::text as uuid) ref
    FROM "odins"."DIM_Товары_buffer" b
    WHERE b.dt_update = var_mindate;

    GET DIAGNOSTICS var_rowcount = ROW_COUNT;
    par_rowcount := var_rowcount;

    IF var_rowcount = 0 THEN
        RETURN;
    END IF;

    BEGIN
        INSERT INTO "DIM_Товары_tmp1" (buffer_id, "RefID")
        SELECT MAX(buffer_id) AS buffer_id,
            "RefID"
        FROM "DIM_Товары_lock" b
        GROUP BY "RefID";

        GET DIAGNOSTICS var_rowcount = ROW_COUNT;
        par_rowcount := var_rowcount;

        DROP TABLE IF EXISTS "DIM_Товары_tmp2";
        CREATE TEMPORARY TABLE "DIM_Товары_tmp2" (
            "nkey" uuid,
            "RefID" uuid,
            "DeletionMark" boolean,
            "Code" varchar(128),
            "Description" varchar(128),
            "Описание" varchar(255),
            "dt_update" timestamp without time zone 
        );

        INSERT INTO "DIM_Товары_tmp2"
        (
        SELECT
            CAST(md5(CONVERT(
                    CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Товары/nva:Ref/text()', msg::xml, var_xmlns ))[1] as VARCHAR)                    
                    ::bytea,'UTF8','UHC')) AS UUID) AS "nkey",

            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Товары/nva:Ref/text()', msg::xml, var_xmlns ))[1]::text as uuid)  AS "RefID",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Товары/nva:DeletionMark/text()', msg::xml, var_xmlns ))[1]::text as boolean)  AS "DeletionMark",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Товары/nva:Code/text()', msg::xml, var_xmlns ))[1]::text as varchar(128))  AS "Code",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Товары/nva:Description/text()', msg::xml, var_xmlns ))[1]::text as varchar(128))  AS "Description",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Товары/nva:Описание/text()', msg::xml, var_xmlns ))[1]::text as varchar(255))  AS "Описание",
            CAST(now() as timestamp without time zone) 
        FROM "odins"."DIM_Товары_buffer" AS b
        WHERE b."is_error" = false AND EXISTS (SELECT 1 FROM "DIM_Товары_tmp1" AS t WHERE CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Товары/nva:Ref/text()', msg::xml, var_xmlns ))[1]::text as uuid) = t."RefID" AND b.buffer_id = t.buffer_id )
        );

        UPDATE "odins"."DIM_Товары" AS org SET
            "nkey" = src."nkey",
            "RefID" = src."RefID",
            "DeletionMark" = src."DeletionMark",
            "Code" = src."Code",
            "Description" = src."Description",
            "Описание" = src."Описание",
            dt_update = var_updatedate
        FROM "DIM_Товары_tmp2" AS src 
        WHERE org."nkey" = src."nkey" ;

        INSERT INTO "odins"."DIM_Товары" (
            "nkey" ,
            "RefID",
            "DeletionMark",
            "Code",
            "Description",
            "Описание",
            dt_update
        )
        SELECT 
            src."nkey" ,
            src."RefID",
            src."DeletionMark",
            src."Code",
            src."Description",
            src."Описание",
            src."dt_update"
         FROM "DIM_Товары_tmp2" AS src 
            LEFT JOIN "odins"."DIM_Товары" AS org ON org."nkey" = src."nkey" 
         WHERE org."RefID" IS NULL ;


        -- Clear buffer table
        IF var_buffer_history_mode = 1 AND NOT EXISTS (SELECT 1 FROM "odins"."DIM_Товары_buffer" WHERE is_error = true) THEN

            DELETE FROM "odins"."DIM_Товары_buffer" AS org
                USING "DIM_Товары_lock" AS src
            WHERE org."buffer_id" = src."buffer_id";

        ELSE

            UPDATE "odins"."DIM_Товары_buffer" AS org SET
                dt_update = var_updatedate
            FROM "DIM_Товары_lock" AS src
            WHERE org."buffer_id" = src."buffer_id";

            IF var_buffer_history_mode >= 2 AND NOT EXISTS (SELECT 1 FROM "odins"."DIM_Товары_buffer" WHERE is_error = true) THEN
                DELETE
                FROM "odins"."DIM_Товары_buffer" AS b
                WHERE EXTRACT(DAY FROM var_updatedate::timestamp - dt_update::timestamp) > var_bufferhistorydays;
            END IF;
        END    IF;

    EXCEPTION WHEN OTHERS
    THEN
        GET STACKED DIAGNOSTICS
        par_errmessage = MESSAGE_TEXT;

        SELECT COALESCE(par_session_id, 0) INTO var_err_session_id;
        INSERT INTO session_log (session_id, session_state_id, error_message)
        SELECT var_err_session_id,
            3 AS session_state_id,
            'Table odins.DIM_Товары. Error: ' || par_errmessage AS error_message;

        UPDATE "odins"."DIM_Товары_buffer" AS org SET
            is_error  = true,
            dt_update = var_updatedate
        FROM "DIM_Товары_lock" AS src
        WHERE org."buffer_id" = src."buffer_id";

    END;
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE odins."load_FACT_Продажи_file"';
END;
$$;

CREATE OR REPLACE PROCEDURE odins."load_FACT_Продажи_file" (
    par_session_id in bigint DEFAULT NULL, 
    par_rowcount inout int DEFAULT NULL 
)
AS $BODY$
DECLARE
    var_rowcount int;
BEGIN

    DROP TABLE IF EXISTS "FACT_Продажи_tmp1";
    
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE odins."load_FACT_Продажи_staging"';
END;
$$;

CREATE OR REPLACE PROCEDURE odins."load_FACT_Продажи_staging" (
    par_session_id in bigint DEFAULT NULL, 
    par_rowcount inout int DEFAULT NULL 
)
AS $BODY$
DECLARE
    var_rowcount int;
BEGIN

    DROP TABLE IF EXISTS "FACT_Продажи_tmp1";

END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE odins."load_FACT_Продажи"';
END;
$$;

--CALL odins."load_FACT_Продажи"(NULL::bigint, 1::smallint, NULL::integer, NULL::varchar(4000))
CREATE OR REPLACE PROCEDURE odins."load_FACT_Продажи" (
    IN par_session_id bigint DEFAULT NULL,
    IN par_buffer_history_mode smallint DEFAULT 2::smallint,  -- 0 - Do not delete the buffering history.
                                                              -- 1 - Delete the buffering history.
                                                              -- 2 - Keep the buffering history for 10 days.
                                                              -- 3 - Keep the buffering history for a month.
    INOUT par_rowcount integer DEFAULT NULL::integer,
    INOUT par_errmessage varchar(4000) DEFAULT NULL::varchar(4000)
)
AS $BODY$
DECLARE
    var_rowcount integer;
    var_xmlns text ARRAY;
    var_mindate timestamp without time zone;
    var_updatedate timestamp without time zone;
    var_bufferhistorydays int;
    var_err_session_id bigint;
    var_buffer_history_mode smallint;
BEGIN
    var_buffer_history_mode := CASE WHEN par_buffer_history_mode IS NULL OR par_buffer_history_mode > 2 THEN 2 ELSE par_buffer_history_mode END;
    SELECT now() INTO var_updatedate;
    SELECT to_date('19000101', 'YYYYMMDD') INTO var_mindate;
    SELECT (CASE WHEN (par_buffer_history_mode = 2) THEN 10 ELSE 30 END) INTO var_bufferhistorydays;

    SELECT ARRAY[ARRAY['nva', 'http://v8.1c.ru/8.1/data/enterprise/current-config'], ARRAY['xsi', 'http://www.w3.org/2001/XMLSchema-instance'], ARRAY['xs', 'http://www.w3.org/2001/XMLSchema']] into var_xmlns;

    DROP TABLE IF EXISTS "FACT_Продажи_lock";
    CREATE TEMPORARY TABLE "FACT_Продажи_lock" (
        "buffer_id" int,
        "RefID" uuid
    );

    DROP TABLE IF EXISTS "FACT_Продажи_tmp1";
    CREATE TEMPORARY TABLE "FACT_Продажи_tmp1" (
        "buffer_id" int,
        "RefID" uuid
    );

    INSERT INTO "FACT_Продажи_lock" (buffer_id, "RefID")
    SELECT buffer_id AS buffer_id,
        CAST((xpath('/nva:Data/nva:Реквизиты/nva:CatalogObject.Клиенты/nva:Ref/text()', msg::xml, var_xmlns ))[1]::text as uuid) ref
    FROM "odins"."FACT_Продажи_buffer" b
    WHERE b.dt_update = var_mindate;

    GET DIAGNOSTICS var_rowcount = ROW_COUNT;
    par_rowcount := var_rowcount;

    IF var_rowcount = 0 THEN
        RETURN;
    END IF;

    BEGIN
        INSERT INTO "FACT_Продажи_tmp1" (buffer_id, "RefID")
        SELECT MAX(buffer_id) AS buffer_id,
            "RefID"
        FROM "FACT_Продажи_lock" b
        GROUP BY "RefID";

        GET DIAGNOSTICS var_rowcount = ROW_COUNT;
        par_rowcount := var_rowcount;

        DROP TABLE IF EXISTS "FACT_Продажи_tmp2";
        CREATE TEMPORARY TABLE "FACT_Продажи_tmp2" (
            "nkey" uuid,
            "FACT_Продажи_Товары"  xml,
            "RefID" uuid,
            "DeletionMark" boolean,
            "Number" integer,
            "Posted" boolean,
            "Date" timestamp,
            "ДатаОтгрузки" timestamp,
            "Клиент" varchar(36),
            "ТипДоставки" varchar(500),
            "ПримерСоставногоТипа" varchar(36),
            "ПримерСоставногоТипа_ТипЗначения" varchar(128),
            "dt_update" timestamp without time zone 
        );

        INSERT INTO "FACT_Продажи_tmp2"
        (
        SELECT
            CAST(md5(CONVERT(
                    CAST((xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:Ref/text()', msg::xml, var_xmlns ))[1] as VARCHAR)                    
                    ::bytea,'UTF8','UHC')) AS UUID) AS "nkey",

            (xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:FACT_Продажи.Товары/text()', msg::xml, var_xmlns ))[1]::xml  AS "FACT_Продажи_Товары",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:Ref/text()', msg::xml, var_xmlns ))[1]::text as uuid)  AS "RefID",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:DeletionMark/text()', msg::xml, var_xmlns ))[1]::text as boolean)  AS "DeletionMark",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:Number/text()', msg::xml, var_xmlns ))[1]::text as integer)  AS "Number",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:Posted/text()', msg::xml, var_xmlns ))[1]::text as boolean)  AS "Posted",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:Date/text()', msg::xml, var_xmlns ))[1]::text as timestamp)  AS "Date",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:ДатаОтгрузки/text()', msg::xml, var_xmlns ))[1]::text as timestamp)  AS "ДатаОтгрузки",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:Клиент/text()', msg::xml, var_xmlns ))[1]::text as varchar(36))  AS "Клиент",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:ТипДоставки/text()', msg::xml, var_xmlns ))[1]::text as varchar(500))  AS "ТипДоставки",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:ПримерСоставногоТипа/text()', msg::xml, var_xmlns ))[1]::text as varchar(36))  AS "ПримерСоставногоТипа",
            CAST((xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:ПримерСоставногоТипа/@xsi:type', msg::xml, var_xmlns ))[1]::text as varchar(128))  AS "ПримерСоставногоТипа_ТипЗначения",
            CAST(now() as timestamp without time zone) 
        FROM "odins"."FACT_Продажи_buffer" AS b
        WHERE b."is_error" = false AND EXISTS (SELECT 1 FROM "FACT_Продажи_tmp1" AS t WHERE CAST((xpath('/nva:Data/nva:Реквизиты/nva:DocumentObject.Продажи/nva:Ref/text()', msg::xml, var_xmlns ))[1]::text as uuid) = t."RefID" AND b.buffer_id = t.buffer_id )
        );

        UPDATE "odins"."FACT_Продажи" AS org SET
            "nkey" = src."nkey",
            "RefID" = src."RefID",
            "DeletionMark" = src."DeletionMark",
            "Number" = src."Number",
            "Posted" = src."Posted",
            "Date" = src."Date",
            "ДатаОтгрузки" = src."ДатаОтгрузки",
            "Клиент" = src."Клиент",
            "ТипДоставки" = src."ТипДоставки",
            "ПримерСоставногоТипа" = src."ПримерСоставногоТипа",
            "ПримерСоставногоТипа_ТипЗначения" = src."ПримерСоставногоТипа_ТипЗначения",
            dt_update = var_updatedate
        FROM "FACT_Продажи_tmp2" AS src 
        WHERE org."nkey" = src."nkey" ;

        INSERT INTO "odins"."FACT_Продажи" (
            "nkey" ,
            "RefID",
            "DeletionMark",
            "Number",
            "Posted",
            "Date",
            "ДатаОтгрузки",
            "Клиент",
            "ТипДоставки",
            "ПримерСоставногоТипа",
            "ПримерСоставногоТипа_ТипЗначения",
            dt_update
        )
        SELECT 
            src."nkey" ,
            src."RefID",
            src."DeletionMark",
            src."Number",
            src."Posted",
            src."Date",
            src."ДатаОтгрузки",
            src."Клиент",
            src."ТипДоставки",
            src."ПримерСоставногоТипа",
            src."ПримерСоставногоТипа_ТипЗначения",
            src."dt_update"
         FROM "FACT_Продажи_tmp2" AS src 
            LEFT JOIN "odins"."FACT_Продажи" AS org ON org."nkey" = src."nkey" 
         WHERE org."RefID" IS NULL ;


        -- Clear buffer table
        IF var_buffer_history_mode = 1 AND NOT EXISTS (SELECT 1 FROM "odins"."FACT_Продажи_buffer" WHERE is_error = true) THEN

            DELETE FROM "odins"."FACT_Продажи_buffer" AS org
                USING "FACT_Продажи_lock" AS src
            WHERE org."buffer_id" = src."buffer_id";

        ELSE

            UPDATE "odins"."FACT_Продажи_buffer" AS org SET
                dt_update = var_updatedate
            FROM "FACT_Продажи_lock" AS src
            WHERE org."buffer_id" = src."buffer_id";

            IF var_buffer_history_mode >= 2 AND NOT EXISTS (SELECT 1 FROM "odins"."FACT_Продажи_buffer" WHERE is_error = true) THEN
                DELETE
                FROM "odins"."FACT_Продажи_buffer" AS b
                WHERE EXTRACT(DAY FROM var_updatedate::timestamp - dt_update::timestamp) > var_bufferhistorydays;
            END IF;
        END    IF;

    EXCEPTION WHEN OTHERS
    THEN
        GET STACKED DIAGNOSTICS
        par_errmessage = MESSAGE_TEXT;

        SELECT COALESCE(par_session_id, 0) INTO var_err_session_id;
        INSERT INTO session_log (session_id, session_state_id, error_message)
        SELECT var_err_session_id,
            3 AS session_state_id,
            'Table odins.FACT_Продажи. Error: ' || par_errmessage AS error_message;

        UPDATE "odins"."FACT_Продажи_buffer" AS org SET
            is_error  = true,
            dt_update = var_updatedate
        FROM "FACT_Продажи_lock" AS src
        WHERE org."buffer_id" = src."buffer_id";

    END;
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'Create table staging.DIM_Валюты';
END;
$$;
CREATE TABLE IF NOT EXISTS "staging"."DIM_Валюты" (
    id         bigint  NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    nkey       uuid NOT NULL,
    "RefID"            uuid  NULL,
    "DeletionMark"            boolean  NULL,
    "Code"            varchar(128)  NULL,
    "Description"            varchar(128)  NULL,
    "ЗагружаетсяИзИнтернета"            boolean  NULL,
    "НаименованиеПолное"            varchar(50)  NULL,
    "Наценка"            decimal(10, 2)  NULL,
    "ОсновнаяВалюта"            varchar(36)  NULL,
    "ПараметрыПрописи"            varchar(200)  NULL,
    "ФормулаРасчетаКурса"            varchar(100)  NULL,
    "СпособУстановкиКурса"            varchar(500)  NULL,
    "dt_update"              timestamp without time zone);
do
$$
BEGIN
RAISE NOTICE 'Create table staging.DIM_Клиенты';
END;
$$;
CREATE TABLE IF NOT EXISTS "staging"."DIM_Клиенты" (
    id         bigint  NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    nkey       uuid NOT NULL,
    "RefID"            uuid  NULL,
    "DeletionMark"            boolean  NULL,
    "Code"            varchar(128)  NULL,
    "Description"            varchar(128)  NULL,
    "Контакт"            varchar(500)  NULL,
    "dt_update"              timestamp without time zone);
do
$$
BEGIN
RAISE NOTICE 'Create table staging.DIM_Товары';
END;
$$;
CREATE TABLE IF NOT EXISTS "staging"."DIM_Товары" (
    id         bigint  NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    nkey       uuid NOT NULL,
    "RefID"            uuid  NULL,
    "DeletionMark"            boolean  NULL,
    "Code"            varchar(128)  NULL,
    "Description"            varchar(128)  NULL,
    "Описание"            varchar(255)  NULL,
    "dt_update"              timestamp without time zone);
do
$$
BEGIN
RAISE NOTICE 'Create table staging.FACT_Продажи';
END;
$$;
CREATE TABLE IF NOT EXISTS "staging"."FACT_Продажи" (
    id         bigint  NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    nkey       uuid NOT NULL,
    "RefID"            uuid  NULL,
    "DeletionMark"            boolean  NULL,
    "Number"            integer  NULL,
    "Posted"            boolean  NULL,
    "Date"            timestamp  NULL,
    "ДатаОтгрузки"            timestamp  NULL,
    "Клиент"            varchar(36)  NULL,
    "ТипДоставки"            varchar(500)  NULL,
    "ПримерСоставногоТипа"            varchar(36)  NULL,
    "ПримерСоставногоТипа_ТипЗначения"            varchar(128)  NULL,
    "dt_update"              timestamp without time zone);
