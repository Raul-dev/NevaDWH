CREATE SCHEMA IF NOT EXISTS odins;
CREATE SCHEMA IF NOT EXISTS staging;

CREATE TABLE IF NOT EXISTS public.codegen_dwh_column
(
    codegen_dwh_column_id integer           NOT NULL,
    codegen_dwh_table_id integer           NOT NULL,
    column_name           character varying(128) COLLATE pg_catalog."default" NOT NULL,
    data_type             character varying(128) COLLATE pg_catalog."default" NOT NULL,
    text_length           integer           NULL,
    precision             integer           NULL,
    scale                 integer           NULL,
    is_enable             boolean           CONSTRAINT DF_codegen_dwh_column_is_enable_DEFAULT DEFAULT ((true)) NOT NULL,
    is_versionkey         boolean           CONSTRAINT DF_codegen_dwh_column_is_versionkey_DEFAULT DEFAULT ((false)) NOT NULL,
    is_nulable            boolean           CONSTRAINT DF_codegen_dwh_column_is_nulable_DEFAULT DEFAULT ((true)) NOT NULL,
    null_value            VARCHAR (128),
    CONSTRAINT "PK_codegen_dwh_column" PRIMARY KEY (codegen_dwh_column_id)

)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.codegen_dwh_column
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.codegen_dwh_table
(

    codegen_dwh_table_id integer           NOT NULL,
    codegen_id            integer           NOT NULL,
    table_name            character varying(128) COLLATE pg_catalog."default" NOT NULL,
    is_root               boolean           NOT NULL,
    is_enable             boolean           NOT NULL,
    dwh_table_name        character varying(128) COLLATE pg_catalog."default" NOT NULL,
    is_vkey_session       boolean           CONSTRAINT DF_codegen_dwh_table_is_vkey_session_DEFAULT DEFAULT ((true)) NOT NULL,
    is_vkey_sourcename    boolean           CONSTRAINT DF_codegen_dwh_table_is_vkey_sourcename_DEFAULT DEFAULT ((true)) NOT NULL,
    is_historical         boolean           CONSTRAINT DF_codegen_dwh_table_is_historical_DEFAULT DEFAULT ((true)) NOT NULL,
    CONSTRAINT "PK_codegen_dwh_table" PRIMARY KEY (codegen_dwh_table_id)

)
TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.codegen_dwh_table
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.codegen_enable_type
(
    codegen_enable_type_id  SMALLINT            NOT NULL,
    description   character varying(256) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "PK_codegen_enable_type" PRIMARY KEY (codegen_enable_type_id)
)


TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.codegen_enable_type
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.codegen
(
    codegen_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    namespace character varying(256) COLLATE pg_catalog."default" NOT NULL,
    schema character varying(128) COLLATE pg_catalog."default" NOT NULL,
    table_name character varying(128) COLLATE pg_catalog."default" NOT NULL,
    ods_enable_type smallint NULL,
    dwh_enable_type smallint NULL,
    landing_enable_type smallint NULL,
    CONSTRAINT "PK_codegen" PRIMARY KEY (codegen_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.codegen
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.data_source(
    data_source_id smallint       NOT NULL,
    name           character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "PK_data_source" PRIMARY KEY (data_source_id)
);
CREATE TABLE IF NOT EXISTS dwh_processing_details (
    processing_id  bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) PRIMARY KEY,
    dwh_session_id BIGINT        NULL,
    schema_name    VARCHAR (128) NULL,
    table_name     VARCHAR (128) NULL,
    row_count      BIGINT        NULL
);

CREATE TABLE IF NOT EXISTS dwh_session_log (
    dwh_session_log_id   bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) PRIMARY KEY,
    dwh_session_id       BIGINT         NOT NULL,
    dwh_session_state_id smallint        NOT NULL,
    error_message        VARCHAR (4000) NULL,
    dt_create            timestamp with time zone NOT NULL 
);

CREATE TABLE IF NOT EXISTS dwh_session_state (
    dwh_session_state_id smallint       NOT NULL,
    name                 VARCHAR (100) NULL
);
CREATE TABLE IF NOT EXISTS dwh_session (
    dwh_session_id       bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) PRIMARY KEY,
    data_source_id       smallint         NOT NULL,
    dwh_session_state_id smallint         NOT NULL,
    create_session       timestamp with time zone,
    error_message        VARCHAR (4000) NULL,
    dt_update            timestamp with time zone NOT NULL default now(),
    dt_create            timestamp with time zone NOT NULL default now()
    
);


CREATE TABLE IF NOT EXISTS public.filequeue (
    filequeue_id     bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) ,
    session_id  bigint  NOT NULL,
    msg_key character varying(256) COLLATE pg_catalog."default" NOT NULL,
    msg_id uuid NULL,
    start_date timestamp with time zone NULL,
    finish_date timestamp with time zone NULL,
    filename character varying(4000) COLLATE pg_catalog."default" NULL,
    filefolder character varying(4000) COLLATE pg_catalog."default" NULL,
    filetype character varying(4) COLLATE pg_catalog."default" NULL,
    error_msg character varying(4000) COLLATE pg_catalog."default" NULL,
    state_id smallint NOT NULL,
    dt_create timestamp with time zone  CONSTRAINT DF_filequeue_create_date_DEFAULT DEFAULT (now()) NOT NULL,
    dt_update timestamp with time zone  CONSTRAINT DF_filequeue_update_date_DEFAULT DEFAULT (now()) NOT NULL,
    CONSTRAINT PK_filequeue PRIMARY KEY (filequeue_id)
);



CREATE TABLE IF NOT EXISTS public.metaadapter 
(
    metaadapter_id smallint       NOT NULL,
    name             character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "PK_metaadapter" PRIMARY KEY (metaadapter_id)
);

CREATE TABLE IF NOT EXISTS public.metadata_buffer
(
    buffer_id   bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    session_id  bigint NOT NULL,
    msg_id      character varying(36) COLLATE pg_catalog."default",
    msg         text COLLATE pg_catalog."default",
    is_error    boolean CONSTRAINT DF_metadata_buffer_is_error_DEFAULT DEFAULT ((false)) NOT NULL,
    dt_create   timestamp with time zone NOT NULL default now()
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.metadata_buffer
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.metadata_sql
(
    "id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) ,
    "guid" uuid NULL,
    "column_order" int NOT NULL,
    "s_schema_type" varchar(128) ,
    "s_table_name" varchar(128) ,
    "s_column_name" varchar(128) ,
    "s_data_type" varchar(128) ,
    "s_text_length" varchar(128) ,
    "s_precision" varchar(128) ,
    "s_scale" varchar(128) ,
    "s_is_nkey" boolean NOT NULL,
    "t_star_name" varchar(128) ,
    "t_table_name" varchar(128) ,
    "t_column_name" varchar(128) ,
    "t_data_type" varchar(128) ,
    "t_text_length" varchar(128) ,
    "t_precision" varchar(128) ,
    "t_scale" varchar(128) ,
    "t_is_nkey" boolean NOT NULL,
    "t_is_fkey" boolean NOT NULL,
    "t_is_present" boolean NOT NULL,
    "t_is_vkey" boolean NOT NULL,
    "t_history_type" varchar(100) ,
    "t_is_aggr" boolean NOT NULL,
    "t_aggr_type" varchar(100) ,
    "description" varchar(4000) ,
    CONSTRAINT "PK_metadata_sql" PRIMARY KEY (id)
) 


TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.metadata_sql
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.metadata
(
    nkey uuid NOT NULL,
    namespace character varying(256) COLLATE pg_catalog."default",
    namespace_ver character varying(256) COLLATE pg_catalog."default",
    msg text COLLATE pg_catalog."default",
    metaadapter_id smallint NOT NULL,
    dt_create timestamp with time zone NOT NULL,
    CONSTRAINT "PK_metadata" PRIMARY KEY (nkey)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.metadata
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.metamap
(
    metamap_id smallint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 32767 CACHE 1 ),
    msg_key character varying(128) COLLATE pg_catalog."default" NOT NULL,
    table_name character varying(128) COLLATE pg_catalog."default" NOT NULL,
    metaadapter_id smallint NOT NULL,
    namespace character varying(256) COLLATE pg_catalog."default",
    namespace_ver character varying(256) COLLATE pg_catalog."default",
    etl_query character varying(256) COLLATE pg_catalog."default",
    import_query character varying(256) COLLATE pg_catalog."default",
    is_enable boolean NOT NULL,
    CONSTRAINT "PK_metamap" PRIMARY KEY (metamap_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.metamap
    OWNER to postgres;

CREATE TABLE IF NOT EXISTS public.msgqueue
(
    buffer_id  bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    session_id bigint NOT NULL,
    msg_id uuid NOT NULL,
    msg text COLLATE pg_catalog."default",
    msg_key character varying(128) COLLATE pg_catalog."default",
    dt_create timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT "PK_msgqueue" PRIMARY KEY (buffer_id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.msgqueue
    OWNER to postgres;
CREATE TABLE IF NOT EXISTS public.session_log 
(

    session_log_id   bigint    NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    session_id       bigint   NOT NULL,
    session_state_id smallint  NOT NULL,
    error_message    character varying(4000) COLLATE pg_catalog."default",
    dt_create        timestamp with time zone  CONSTRAINT DF_session_log_date_DEFAULT DEFAULT (now()) NOT NULL,
    CONSTRAINT "PK_session_log" PRIMARY KEY (session_log_id)
);

CREATE TABLE IF NOT EXISTS public.session_state 
(
    session_state_id smallint       NOT NULL,
    name             character varying(100) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "PK_session_state" PRIMARY KEY (session_state_id )
);


CREATE TABLE IF NOT EXISTS public.session (
    session_id       bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ) ,
    data_source_id   smallint        NOT NULL,
    session_state_id smallint    NOT NULL,
    error_message    character varying(4000) COLLATE pg_catalog."default" NULL,
    dt_update        timestamp with time zone  CONSTRAINT DF_session_update_date_DEFAULT DEFAULT (now()) NOT NULL,
    dt_create        timestamp with time zone  CONSTRAINT DF_session_create_date_DEFAULT DEFAULT (now()) NOT NULL,
    CONSTRAINT PK_session PRIMARY KEY (session_id)
);



do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE "dwh_ArchiveTables"';
END;
$$;

CREATE OR REPLACE PROCEDURE "dwh_ArchiveTables" (
    par_dwh_session_id inout INT DEFAULT NULL
)
AS $BODY$
DECLARE
    var_RowCount INTEGER;
    var_LocalRowCount  INTEGER;
BEGIN

   
    
        UPDATE dwh_session SET dwh_session_state_id = 6
    WHERE dwh_session_id = par_dwh_session_id;
    
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE "dwh_AssignSessionID"';
END;
$$;

-- SELECT * FROM dwh_processing_details
-- call public."dwh_AssignSessionID" (null, null)
CREATE OR REPLACE PROCEDURE "dwh_AssignSessionID" (
    INOUT par_dwh_session_id bigint DEFAULT NULL::bigint,
    INOUT par_rowcount bigint DEFAULT NULL::bigint,
    INOUT par_create_session timestamp DEFAULT NULL::timestamp
)
AS $BODY$
DECLARE
    var_RowCount INTEGER;
    var_LocalRowCount INTEGER;
BEGIN

    par_rowcount:= 0;
    IF NOT par_dwh_session_id IS NULL AND par_dwh_session_id != -1 THEN

        SELECT INTO par_dwh_session_id, par_rowcount, par_create_session
        FROM (
            SELECT s.dwh_session_id, sum(row_count) as row_count, MAX(s.create_session) AS create_session
            FROM dwh_session s
                INNER JOIN dwh_processing_details p ON p.dwh_session_id = s.dwh_session_id
            WHERE dwh_session_state_id = 2 AND s.dwh_session_id = par_dwh_session_id
            GROUP BY s.dwh_session_id
        ) s;
        RETURN ;
    END IF;

    SELECT create_session INTO par_create_session FROM dwh_session WHERE dwh_session_id = par_dwh_session_id;
END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE "dwh_SaveSessionState"';
END;
$$;
/*
call "dwh_SaveSessionState" (par_dwh_session_id =1, par_data_source_id =1, par_dwh_session_state_id=1, par_error_message 'ok' ) 
call public."dwh_SaveSessionState" (null::bigint, 1::smallint, 1::smallint, 'ok'::varchar(4000) ) 
call public."dwh_SaveSessionState" (1::bigint, 1::smallint, 1::smallint, 'ok'::varchar(4000) ) 
SELECT * FROM dwh_session
*/
CREATE OR REPLACE PROCEDURE "dwh_SaveSessionState" (
    par_dwh_session_id INOUT BIGINT DEFAULT NULL, 
    par_data_source_id IN smallint DEFAULT NULL, 
    par_dwh_session_state_id IN smallint DEFAULT NULL, 
    par_error_message IN varchar(4000) DEFAULT NULL 
)
AS $BODY$
DECLARE
    var_RowCount INTEGER;
BEGIN

    IF par_dwh_session_id IS NULL THEN
    
        SELECT  MAX(dwh_session_id) into par_dwh_session_id FROM dwh_session WHERE dwh_session_state_id = 1;
        IF NOT par_dwh_session_id IS NULL THEN
            RETURN;
        END IF;    

        INSERT INTO dwh_session (data_source_id,    dwh_session_state_id,    error_message)
        VALUES(par_data_source_id, par_dwh_session_state_id, par_error_message);
        
        SELECT currval(pg_get_serial_sequence('dwh_session','dwh_session_id')) into par_dwh_session_id;
        RETURN;
    
    ELSE
    
        UPDATE dwh_session
            SET 
                dwh_session_state_id = par_dwh_session_state_id,    
                error_message = par_error_message,
                create_session = CASE WHEN par_dwh_session_state_id = 2 THEN now() ELSE create_session END,
                dt_update = now()
        WHERE dwh_session_id = par_dwh_session_id;
    END IF;

END;

$BODY$
LANGUAGE plpgsql;
    
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE "load_metadata"';
END;
$$;
-- CALL load_metadata(NULL,NULL);
CREATE OR REPLACE PROCEDURE "load_metadata" (
    par_session_id IN BIGINT  DEFAULT NULL, 
    par_rowcount inout INT DEFAULT NULL 
)
AS $BODY$
DECLARE
    var_RowCount INTEGER;
BEGIN

    DROP TABLE IF EXISTS "metadata_tmp1";
    CREATE TEMPORARY TABLE "metadata_tmp1" (
        buffer_id int,
        "namespace_ver" varchar(256)
    );
    LOCK TABLE metadata_buffer IN ROW EXCLUSIVE MODE;

    INSERT INTO "metadata_tmp1" (
        SELECT buffer_id,
        CAST(msg as json)->'Реквизиты'->0->>'ПространствоИменСВерсией' AS "namespace_ver"
        FROM "metadata_buffer" b
        WHERE b."is_error" = false FOR UPDATE
    );
    GET DIAGNOSTICS var_rowcount = ROW_COUNT;
    par_rowcount := var_rowcount;

    IF var_rowcount = 0 THEN
        return;
    END IF;

    DROP TABLE IF EXISTS "metadata_tmp2";
    CREATE TEMPORARY TABLE "metadata_tmp2" (
        nkey uuid NOT NULL,
        namespace character varying(256) ,
        namespace_ver character varying(256) ,
        msg text ,
        type character varying(128) ,
        dt_create timestamp with time zone NOT NULL,
        CONSTRAINT "PK_metadata" PRIMARY KEY (nkey)
    );

    INSERT INTO "metadata_tmp2" (
    SELECT 
        CAST(md5(CONVERT(
            (CAST(msg as json)->'Реквизиты'->0->>'ПространствоИменСВерсией')
            ::bytea,'UTF8','UHC')) AS UUID) AS  nkey,

        CAST(msg as json)->'Реквизиты'->0->>'ПространствоИменИсходное' AS "namespace",
        CAST(msg as json)->'Реквизиты'->0->>'ПространствоИменСВерсией' AS "namespace_ver",
        msg, 'json' as type, now()
        FROM "metadata_buffer" b
            INNER JOIN (SELECT MAX(buffer_id) AS buffer_id FROM metadata_tmp1 GROUP BY namespace_ver ) t ON b.buffer_id = t.buffer_id
        WHERE b."is_error" = false 
    );

    UPDATE metadata AS t SET
        namespace = b.namespace,
        namespace_ver = b.namespace_ver,
        msg = b.msg,
        type = b.type
     FROM metadata_tmp2 b
     WHERE 
        b.nkey = t.nkey;


    INSERT INTO metadata (
        SELECT b.* FROM metadata_tmp2 b
        WHERE NOT EXISTS (SELECT 1 FROM metadata t WHERE b.nkey = t.nkey )
    );

    DELETE 
    FROM metadata_buffer as trg
    USING metadata_tmp1 AS tmp
    WHERE 
        trg.buffer_id = tmp.buffer_id;

END;

$BODY$
LANGUAGE plpgsql;
do
$$
BEGIN
RAISE NOTICE 'CREATE PROCEDURE public."rb_SaveSessionState"';

END;
$$;

CREATE OR REPLACE PROCEDURE public."rb_SaveSessionState" (
    par_session_id INOUT bigint DEFAULT NULL, 
    par_data_source_id IN smallint = 1,
    par_session_state_id IN smallint = 1,
    par_error_message IN varchar(4000) DEFAULT NULL 
)
AS $BODY$
BEGIN
    IF par_session_id IS NULL THEN
    
           INSERT INTO "session" (data_source_id,    session_state_id,    error_message)
        VALUES(par_data_source_id, par_session_state_id, par_error_message);
        
        SELECT currval(pg_get_serial_sequence('session','session_id')) into par_session_id;
        RETURN;
    ELSE
        UPDATE "session"
        SET data_source_id = par_data_source_id,
            session_state_id = par_session_state_id,
            dt_update = now()
        WHERE session_id = par_session_id;
    END IF;
END;

$BODY$
LANGUAGE plpgsql;
